<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <title>three.js practice</title>
        <style>
            body { margin: 0; }
            canvas { width: 100%; height: 100%; }
        </style>
    </head>
    <body>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.min.js"></script>
        <script src="https://threejs.org/build/three.min.js"></script>
        <script src='js/threex.basiclighting.js'></script>
        <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
        <script src='js/threex.basiclighting.js'></script>
        <script>
            var WIDTH = window.innerWidth;
            var HEIGHT = window.innerHeight;
            var aspect = WIDTH / HEIGHT;
            var viewSize = 8;
            var mouse = new THREE.Vector2();
            var ray = new THREE.Raycaster();
            var offset = new THREE.Vector3();
            var selected = null;

            var scene = new THREE.Scene();
            scene.background = new THREE.Color(0xFAFAE4);

            //var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            var camera = new THREE.OrthographicCamera( viewSize * aspect / - 2, viewSize * aspect / 2, viewSize / 2, viewSize / - 2, 1, 1000 );
            
            var renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(WIDTH, HEIGHT);
            document.body.appendChild(renderer.domElement);

            var controls = new THREE.OrbitControls (camera, renderer.domElement);
            controls.addEventListener("change",
                function(){
                    camera.updateProjectionMatrix();
                    camera.updateMatrixWorld();
                    console.log("Camera position: (" + camera.position.x + ", " + camera.position.y + "," + camera.position.z + ")");
                }
            );
            controls.maxPolarAngle = Math.PI/3;
            controls.minPolarAngle = Math.PI/3;

            controls.minAzimuthAngle = -Math.PI/3;
            controls.maxAzimuthAngle = Math.PI/3;

            camera.position.set(100,100,100);
            camera.lookAt(scene.position);
            controls.update();
            camera.updateProjectionMatrix();
            camera.updateMatrixWorld();
            
            var colors = [];
            colors.push(new THREE.Color(0xA8E6CF));
            colors.push(new THREE.Color(0xDCEDC1));
            colors.push(new THREE.Color(0xFFD3B6));
            colors.push(new THREE.Color(0xFFAAA5));

            var sceneObjects = [];
            var objOrder = []; //Record of stacked order
            for(let i=0; i<4; i++) {
                let c = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 1, 1),
                    new THREE.MeshPhongMaterial( { color: colors[i] } )
                );

                //Fix banding as cube meshes overlap
                c.material.polygonOffset = true;
                c.material.polygonOffsetFactor = -0.1*i;

                c.position.set(0, i, 0);
                scene.add(c);
                sceneObjects.push(c);
                objOrder.push(c);
            }

            //Aid object movement
            var plane = new THREE.Mesh(
                new THREE.PlaneBufferGeometry(500, 500, 8, 8),
                new THREE.MeshBasicMaterial({
                    wireframe: true,
                    color: 0xffffff
                })
            );
            plane.material.transparent = true;
            plane.material.opacity = 0;
            scene.add(plane);

            //Lighting
            var light = new THREE.PointLight();
            light.position.set(5, 5, 5);
            scene.add(light);

            var lighting = new THREEx.ThreePointsLighting();
            scene.add(lighting);

            document.addEventListener('mousedown', function(){ 
                event.preventDefault();

                mouse.set((event.clientX/WIDTH)*2 - 1, -(event.clientY/HEIGHT)*2 + 1);
                ray.setFromCamera(mouse, camera);
                var hits = ray.intersectObjects(sceneObjects);

                if(hits.length > 0) {
                    selected = hits[0].object;
                    selected.material.transparent = true;
                    selected.material.opacity = 0.6;
                    controls.enabled = false;

                    //A new raycast is needed for the correct offset
                    mouse.set(0, -(event.clientY/HEIGHT)*2 + 1);
                    ray.setFromCamera(mouse, camera);
                    var hits = ray.intersectObject(plane);
                    offset.copy(hits[0].point).sub(selected.position);
                }
            });

            document.addEventListener('mouseup', function() {
                if(selected != null) {
                    snapSwap(selected);
                    selected.material.transparent = false;
                    selected = null;
                    controls.enabled = true;
                }
            });

            document.addEventListener('mousemove', onMouseMove, false);

            function onMouseMove(event) { 
                event.preventDefault();

                mouse.set(0, -(event.clientY/HEIGHT)*2 + 1);
                ray.setFromCamera(mouse, camera);
                var hits = ray.intersectObjects(sceneObjects);

                if(selected != null) {
                    var hits = ray.intersectObject(plane);
                    selected.position.copy(hits[0].point.sub(offset));

                    //Lock to y-axis
                    selected.position.x = 0;
                    selected.position.z = 0;

                    snapSwap(selected);
                }
            }

            function animate() {
                requestAnimationFrame(animate);

                controls.update();

                //Animate swapping to correct ordering
                for(let i=0; i<objOrder.length; i++) {
                    let obj = objOrder[i];
                    if(obj != selected) {
                        if(obj.position.y != i) {
                            obj.position.lerp(new THREE.Vector3(0, i, 0), OutQuadratic(0.08));
                        }
                    }
                }
                renderer.render(scene, camera);
            }

            function OutQuadratic(t) {
                let s = t - 1;
                return 1-s*s;
            }

            function snapSwap(obj) {
                //Physically snap
                let pos = Math.min(Math.max(0, Math.round(obj.position.y)), 3);
                //obj.position.copy(new THREE.Vector3(0, pos, 0));

                //Swap recorded order
                let temp = objOrder[pos];
                objOrder[objOrder.indexOf(obj)] = temp;
                objOrder[pos] = obj;
            }

            animate();
        </script>
    </body>
</html>