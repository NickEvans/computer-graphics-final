<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <title>three.js practice</title>
        <style>
            body { margin: 0; }
            canvas { width: 100%; height: 100%; }
        </style>
    </head>
    <body>
        <script src="js/three.min.js"></script>
        <script src="https://threejs.org/build/three.min.js"></script>
        <script src="https://threejs.org/examples/js/loaders/OBJLoader.js"></script>
        <script src='js/threex.basiclighting.js'></script>
        <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
        <script src='js/threex.basiclighting.js'></script>
        <script>
            var WIDTH = window.innerWidth;
            var HEIGHT = window.innerHeight;
            var aspect = WIDTH / HEIGHT;
            var viewSize = 8;
            var mouse = new THREE.Vector2();
            var ray = new THREE.Raycaster();
            var offset = new THREE.Vector3();
            var selected = null;

            var clipPlanes = new Array(4);
            var model = new THREE.Mesh();

            var animFinished = false;
            var solved = false;

            var scene = new THREE.Scene();
            //scene.background = new THREE.Color(0xFAFAE4);
            scene.background = new THREE.Color(0x86A3C3);
            var objColor = new THREE.Color(0xB6CEC7);

            //var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            var camera = new THREE.OrthographicCamera( viewSize * aspect / - 2, viewSize * aspect / 2, viewSize / 2, viewSize / - 2, 1, 1000 );
            
            var renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(WIDTH, HEIGHT);
            renderer.localClippingEnabled = true;
            document.body.appendChild(renderer.domElement);

            var controls = new THREE.OrbitControls (camera, renderer.domElement);
            controls.addEventListener("change",
                function(){
                    camera.updateProjectionMatrix();
                    camera.updateMatrixWorld();
                    //console.log("Camera position: (" + camera.position.x + ", " + camera.position.y + "," + camera.position.z + ")");
                }
            );
            //controls.maxPolarAngle = Math.PI/3;
            controls.minPolarAngle = Math.PI/3;
            controls.minAzimuthAngle = -Math.PI/8;
            controls.maxAzimuthAngle = Math.PI/2.2;

            camera.position.set(100,100,100);
            camera.lookAt(scene.position);
            controls.update();
            camera.updateProjectionMatrix();
            camera.updateMatrixWorld();
            
            var colors = [];
            colors.push(new THREE.Color(0xA8E6CF));
            colors.push(new THREE.Color(0xDCEDC1));
            colors.push(new THREE.Color(0xFFD3B6));
            colors.push(new THREE.Color(0xFFAAA5));
            /*
            var einsteinMaterial = new THREE.MeshPhongMaterial( {
                color: colors[1],
                //clippingPlanes: clipPlanes
            } );
            */
            var loader = new THREE.OBJLoader();
            loader.load(
                "models/knight.obj", //"Knight Chess Piece" from Poly by Google is licensed under CC BY 2.0 - https://poly.google.com/view/aW5HcCo0KZa
                function(obj) {
                    obj.traverse(function(child) {
                        if(child instanceof THREE.Mesh) {
                            //child.material = einsteinMaterial;
                            var mod = child.clone();
                            addMeshes(mod);
                        }
                    });
                },
                function(xhr) {
                    if(xhr.lengthComputable) {
                        var percentComplete = xhr.loaded / xhr.total * 100;
                        console.log("Model " + Math.round(percentComplete, 2) + "% loaded");
                    }
                }
            );

            var sceneObjects = [];
            var objOrder = []; //Record of stacked order
            var planeSliceGroups = new Array(4);

            var clipPlanesPrime = [];
            clipPlanes.push(new THREE.Plane(
                new THREE.Vector3(0, -1, 0),
                2
            ));

            function createStencilGroup(object, planes, rendOrder) {
                var group = new THREE.Group();
                var material = new THREE.MeshBasicMaterial();

                //Basic stencil parameters
                material.depthWrite = false;
				material.depthTest = false;
				material.colorWrite = false;
				material.stencilWrite = true;
				material.stencilFunc = THREE.AlwaysStencilFunc;

                //Backsides parameters
                var materialBack = material.clone();
                materialBack.side = THREE.BackSide;
                materialBack.clippingPlanes = planes;
                materialBack.stencilFail = THREE.IncrementWrapStencilOp;
                materialBack.stencilZFail = THREE.IncrementWrapStencilOp;
                materialBack.stencilZPass = THREE.IncrementWrapStencilOp;

                //Frontside parameters
                var materialFront = material.clone();
                materialFront.side = THREE.FrontSide;
                materialFront.clippingPlanes = planes;
                materialFront.stencilFail = THREE.DecrementWrapStencilOp;
                materialFront.stencilZFail = THREE.DecrementWrapStencilOp;
                materialFront.stencilZPass = THREE.DecrementWrapStencilOp;

                //Create front + back mesh group
                var meshBack = new THREE.Mesh(object, materialBack);
                var meshFront = new THREE.Mesh(object, materialFront);
                meshBack.renderOrder = rendOrder;
                meshFront.renderOrder = rendOrder;
                group.add(meshBack);
                group.add(meshFront);

                return group;
            }

            var meshPlanes = [];
            var planeRenderCounter = 0;

            function addMeshes(mod) {
                
                for(let i=0; i<4; i++) {
                    var group = new THREE.Group(); //Group is a "slice" -- a copy of the object mesh with a top and bottom clipping plane
                    scene.add(group);
                    
                    //A set of clipping planes creates a slice of an object
                    clipPlanes[i] = new Array(2);
                    clipPlanes[i][0] = new THREE.Plane(
                        new THREE.Vector3(0, 1, 0), //Lower plane
                        -i + 1
                    );
                    clipPlanes[i][1] = new THREE.Plane(
                        new THREE.Vector3(0, -1, 0), //Upper plane
                        i + 0
                    );

                    

                    /// STENCIL PLANE RENDERING
                    var meshPlaneGroup = new THREE.Group;
                    //var meshPlanes = [];
                    var meshPlaneGeometry = new THREE.PlaneBufferGeometry(1, 1);

                    ///////for(var j=0; j<2; j++) {
                        //var planeMeshGroup = new THREE.Group();
                        var plane = clipPlanes[i];
                        var meshStencilGroup = createStencilGroup(mod.geometry, plane, i);
                        meshStencilGroup.position.set(0,-i,0);

                        var meshPlaneMaterial = new THREE.MeshStandardMaterial({
                            color: objColor,
                            metalness: 0.1,
					        roughness: 0.75,
                            stencilWrite: true,
                            //colorWrite: true,
                            //depthWrite: false,
							stencilRef: 0,
							stencilFunc: THREE.NotEqualStencilFunc,
							stencilFail: THREE.ReplaceStencilOp,
							stencilZFail: THREE.ReplaceStencilOp,
							stencilZPass: THREE.ReplaceStencilOp,
                        });

                        var meshPlane = new THREE.Mesh(meshPlaneGeometry, meshPlaneMaterial);
                        meshPlane.onAfterRender = function(renderer) {
                            renderer.clearStencil();
                        }

                        meshPlaneMaterial.renderOrder = i + 0.1;
                        planeRenderCounter++;
                        
                        group.add(meshStencilGroup);
                        meshPlaneGroup.add(meshPlane);
                        meshPlanes.push(meshPlane);
                        console.log("A thing was pushed... " + meshPlanes.length);
                        scene.add(meshPlaneGroup);
                        
                    /////////}

                    //The object mesh sliced by the plane set
                    var c = new THREE.Mesh(
                        mod.geometry,
                        new THREE.MeshLambertMaterial( { 
                            color: objColor,
                            //shininess: 0,
                            clippingPlanes: clipPlanes[i],
                            clipShadows: true,
					        shadowSide: THREE.DoubleSide
                        } )
                    );
                    
                    c.position.set(0,-i,0); //An offset so each slice is different
                    group.add(c);

                    //Prevents banding where meshes overlap
                    //c.material.polygonOffset = true;
                    //c.material.polygonOffsetFactor = -0.1*i;

                    //c.material.renderOrder = i+20;
                    
                    //Scale the slice to size

                    /*
                    let bbox = new THREE.Box3().setFromObject(c);
                    let size = bbox.getSize();
                    c.scale.set(4 / size.y, 4 / size.y, 4 / size.y);
                    */

                    sceneObjects.push(c);
                    objOrder.push(group);
                    
                    //Move the slice into place (not required)
                    group.position.y = i;
                }
            }

            //Aid object movement
            var plane = new THREE.Mesh(
                new THREE.PlaneBufferGeometry(500, 500, 8, 8),
                new THREE.MeshBasicMaterial({
                    //wireframe: true,
                    //color: 0xffffff,
                    visible: false
                })
            );
            scene.add(plane);

            //Lighting
            var light = new THREE.PointLight(0xffffff, 0.5);
            light.position.set(5, 5, 5);
            light.intensity = 0.5;
            scene.add(light);

            var lighting = new THREEx.ThreePointsLighting();
            scene.add(lighting);

            //EVENTS

            document.addEventListener("mousedown", mouseDown, false);
            document.addEventListener("mouseup", mouseUp, false);
            document.addEventListener("mousemove", onMouseMove, false);
            window.addEventListener("resize", handleResize, false);

            function mouseDown(event) {
                event.preventDefault();

                mouse.set((event.clientX/WIDTH)*2 - 1, -(event.clientY/HEIGHT)*2 + 1);
                ray.setFromCamera(mouse, camera);
                var hits = ray.intersectObjects(sceneObjects);

                for(let i=0; i<hits.length; i++) {
                    let cplanes = hits[i].object.material.clippingPlanes;
                    if(cplanes.length > 0) {
                        if(cplanes.some(function(elem) { return elem.distanceToPoint(hits[i].point) < 0; })) {
                            continue; //Ignore hit outside clipping planes
                        }
                    }

                    selected = hits[i].object;
                    selected.material.transparent = true;
                    selected.material.opacity = 0.6;
                    controls.enabled = false;

                    //A new raycast is needed for the correct offset
                    mouse.set(0, -(event.clientY/HEIGHT)*2 + 1);
                    ray.setFromCamera(mouse, camera);
                    var hits = ray.intersectObject(plane);
                    offset.copy(hits[0].point).sub(selected.parent.position);
                }
            }

            function mouseUp(event) {
                if(selected != null) {
                    updateOrder(selected);
                    selected.material.transparent = false;
                    selected = null;
                    controls.enabled = true;
                }
            }

            function onMouseMove(event) { 
                event.preventDefault();

                mouse.set(0, -(event.clientY/HEIGHT)*2 + 1);
                ray.setFromCamera(mouse, camera);
                var hits = ray.intersectObjects(sceneObjects);

                if(selected != null) {
                    var hits = ray.intersectObject(plane);
                    if(hits.length > 0) {
                        //selected.parent.position.copy(hits[0].point);
                        var planeOffset = selected.parent.position.y;
                        selected.parent.position.copy(hits[0].point.sub(offset));
                        var planeIndex = objOrder.indexOf(selected.parent);
                        clipPlanes[planeIndex].forEach(function(plane) {
                            plane.translate(new THREE.Vector3(0, selected.parent.position.y - planeOffset, 0));
                        })
                    }

                    //Lock to y-axis
                    selected.position.x = 0;
                    selected.position.z = 0;

                    //updateOrder(selected);
                }
            }

            function updateOrder(obj) {
                //Update position
                var pos = Math.min(Math.max(0, Math.round(obj.parent.position.y)), 3);

                //Swap recorded order
                var cur = objOrder.indexOf(obj.parent);
                var temp = objOrder[pos];
                objOrder[cur] = temp;
                objOrder[pos] = obj.parent;

                //Swap clipping planes?
                /*
                var temp = clipPlanes[pos];
                clipPlanes[pos] = clipPlanes[cur];
                clipPlanes[cur] = temp;
                */

                /*
                clipPlanes[cur].forEach(function(plane) {
                    plane.translate(new THREE.Vector3(0, cur - pos, 0));
                });
                clipPlanes[pos].forEach(function(plane) {
                    plane.translate(new THREE.Vector3(0, pos - cur, 0));
                });
                */
            }

            function handleResize() {
                WIDTH = window.innerWidth;
                HEIGHT = window.innerHeight;
                
                aspect = WIDTH / HEIGHT;
                camera.left = viewSize * aspect / - 2;
                camera.right = viewSize * aspect / 2;
                camera.top = viewSize / 2;
                camera.bottom = - viewSize / 2;

                camera.updateProjectionMatrix();
                renderer.setSize(WIDTH, HEIGHT);
                renderer.render(scene, camera);
            }

            var t = 0.0;

            //ANIMATION UPDATE

            function animate() {
                requestAnimationFrame(animate);

                controls.update();

                var done = true;
                //Interpolate each object to its placing
                
                objOrder.forEach(function(obj, i) {
                    var planeLo = clipPlanes[i][0];
                    var planeHi = clipPlanes[i][1];

                    /*
                    if(obj.children.some(function(child){ return child == selected })) {
                        done = false;
                    } else if(Math.abs(Number.parseFloat(obj.position.y).toFixed(2)) == Number.parseFloat(i).toFixed(2)) {
                        done = done && true;
                        //Snap to prevent gaps, or a lengthy animation
                        obj.position.copy(new THREE.Vector3(0, i, 0));
                        planeLo.set(planeLo.normal, -i + 1);
                        planeHi.set(planeHi.normal, i);
                    } else {
                        done = false;
                        obj.position.lerp(new THREE.Vector3(0, i, 0), 0.1536);
                        planeLo.set(planeLo.normal, THREE.Math.lerp(planeLo.constant, -i + 1, 0.1536));
                        planeHi.set(planeHi.normal, THREE.Math.lerp(planeHi.constant, i, 0.1536));
                    }
                    */

                    //Adjust plane objects to clipping planes
                    //var meshLo = meshPlanes[i*2];
                    var meshHi = meshPlanes[i];
                    //console.log(planeLo.normal.y);
                    //console.log(meshLo.position.y);

                    /*
                    planeLo.coplanarPoint(meshLo.position);
                    
                    meshLo.lookAt(
						meshLo.position.x - planeLo.normal.x,
						meshLo.position.y - planeLo.normal.y,
						meshLo.position.z - planeLo.normal.z,
                    );
                    */
                    
                    planeHi.coplanarPoint(meshHi.position);
                    meshHi.lookAt(
						meshHi.position.x - planeHi.normal.x,
						meshHi.position.y - planeHi.normal.y,
						meshHi.position.z - planeHi.normal.z,
                    );
                    //meshHi.position.x -= 0.01;
                    


                });
                
                animFinished = done;

                if(animFinished) {
                    if(objOrder.every(function(group) {
                        group.updateMatrixWorld();
                        var vector = new THREE.Vector3();
                        vector.setFromMatrixPosition(group.children[0].matrixWorld);
                        return (vector.equals(new THREE.Vector3(0, 0, 0)));
                    })) {
                        solved = true;
                    } else {
                        solved = false;
                        t = 0.0;
                        objOrder.forEach(function(group) {
                            group.rotation.y = 0;
                        })
                    }
                }

                if(solved) {
                        objOrder.forEach(function(group) {
                            group.rotation.y = smoothLerp(0, 80, t) * 2 * Math.PI;
                        })
                        t += 1;
                }

                renderer.render(scene, camera);
            }

            function smoothLerp(min, max, x) {
                var p = Math.max(0.0, Math.min(1.0, (x - min) / (max - min)));
                if(p == 1) {
                    spinning = false;
                }
                return p * p * (3.0 - 2.0 * p);
            }

            animate();

        </script>
    </body>
</html>