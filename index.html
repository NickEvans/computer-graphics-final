<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <title>three.js practice</title>
        <style>
            body { margin: 0; }
            canvas { width: 100%; height: 100%; }
        </style>
    </head>
    <body>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.min.js"></script>
        <script src="https://threejs.org/build/three.min.js"></script>
        <script src="https://threejs.org/examples/js/loaders/OBJLoader.js"></script>
        <script src='js/threex.basiclighting.js'></script>
        <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
        <script src='js/threex.basiclighting.js'></script>
        <script>
            var WIDTH = window.innerWidth;
            var HEIGHT = window.innerHeight;
            var aspect = WIDTH / HEIGHT;
            var viewSize = 8;
            var mouse = new THREE.Vector2();
            var ray = new THREE.Raycaster();
            var offset = new THREE.Vector3();
            var selected = null;

            var clipPlanes = new Array(4);
            var model = new THREE.Mesh();

            var animFinished = false;

            var scene = new THREE.Scene();
            scene.background = new THREE.Color(0xFAFAE4);

            //var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            var camera = new THREE.OrthographicCamera( viewSize * aspect / - 2, viewSize * aspect / 2, viewSize / 2, viewSize / - 2, 1, 1000 );
            
            var renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(WIDTH, HEIGHT);
            renderer.localClippingEnabled = true;
            document.body.appendChild(renderer.domElement);

            var controls = new THREE.OrbitControls (camera, renderer.domElement);
            controls.addEventListener("change",
                function(){
                    camera.updateProjectionMatrix();
                    camera.updateMatrixWorld();
                    //console.log("Camera position: (" + camera.position.x + ", " + camera.position.y + "," + camera.position.z + ")");
                }
            );
            controls.maxPolarAngle = Math.PI/3;
            controls.minPolarAngle = Math.PI/3;
            controls.minAzimuthAngle = -Math.PI/8;
            controls.maxAzimuthAngle = Math.PI/2.2;

            camera.position.set(100,100,100);
            camera.lookAt(scene.position);
            controls.update();
            camera.updateProjectionMatrix();
            camera.updateMatrixWorld();
            
            var colors = [];
            colors.push(new THREE.Color(0xA8E6CF));
            colors.push(new THREE.Color(0xDCEDC1));
            colors.push(new THREE.Color(0xFFD3B6));
            colors.push(new THREE.Color(0xFFAAA5));

            var einsteinMaterial = new THREE.MeshPhongMaterial( {
                color: colors[1],
                //clippingPlanes: clipPlanes
            } );
            var loader = new THREE.OBJLoader();
            loader.load(
                "models/knight.obj", //"Knight Chess Piece" from Poly by Google is licensed under CC BY 2.0 - https://poly.google.com/view/aW5HcCo0KZa
                function(obj) {
                    obj.traverse(function(child) {
                        if(child instanceof THREE.Mesh) {
                            //child.material = einsteinMaterial;
                            var mod = child.clone();
                            addMeshes(mod);
                        }
                    });

                    //obj.scale.set(0.2, 0.2, 0.2);
                    //obj.rotation.x = Math.PI/180 * -90;

                    
                    //scene.add(obj);
                },
                function(xhr) {
                    if(xhr.lengthComputable) {
                        var percentComplete = xhr.loaded / xhr.total * 100;
                        console.log("Model " + Math.round(percentComplete, 2) + "% loaded");
                    }
                }
            );   
            /*
            var sceneObjects = [];
            var objOrder = []; //Record of stacked order
            for(let i=0; i<4; i++) {
                let c = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 1, 1),
                    new THREE.MeshPhongMaterial( { color: colors[i] } )
                );

                //Fix banding as cube meshes overlap
                c.material.polygonOffset = true;
                c.material.polygonOffsetFactor = -0.1*i;

                c.position.set(0, i, 0);
                scene.add(c);
                sceneObjects.push(c);
                objOrder.push(c);
            }
            */
            var sceneObjects = [];
            var objOrder = []; //Record of stacked order
            var planeSliceGroups = new Array(4);

            var clipPlanesPrime = [];
            clipPlanes.push(new THREE.Plane(
                new THREE.Vector3(0, -1, 0),
                2
            ));

            function addMeshes(mod) {
                
                for(let i=0; i<4; i++) {
                    var group = new THREE.Group();
                    scene.add(group);
                    clipPlanes[i] = new Array(2);
                    clipPlanes[i][0] = new THREE.Plane(
                        //Lower plane
                        new THREE.Vector3(0, 1, 0),
                        -i + 1
                    );
                    clipPlanes[i][1] = new THREE.Plane(
                        //Upper plane
                        new THREE.Vector3(0, -1, 0),
                        i + 0
                    );
                    var c = new THREE.Mesh(
                        mod.geometry,
                        new THREE.MeshPhongMaterial( { 
                            color: colors[2],
                            shininess: 0,
                            clippingPlanes: clipPlanes[i]
                        } )
                    );

                    c.position.set(0,-i,0);
                    group.add(c);

                    //Fix banding as meshes overlap
                    c.material.polygonOffset = true;
                    c.material.polygonOffsetFactor = -0.1*i;

                    //c.position.set(0, 0, 0);
                    let bbox = new THREE.Box3().setFromObject(c);
                    let size = bbox.getSize();
                    console.log(4/size.y);
                    c.scale.set(4 / size.y, 4 / size.y, 4 / size.y);
                    //"c.scale.set(0.2, 0.2, 0.2);
                    //c.rotation.x = Math.PI/180 * -90;

                    //scene.add(c);
                    //scene.add(group);
                    sceneObjects.push(c);
                    objOrder.push(group);
                }

                for(var i=0; i<4; i++) {
                    console.log("obj " + i + " positioned at " +
                    objOrder[i].position.x + ", " +
                    objOrder[i].position.y + ", " + 
                    objOrder[i].position.z + ".");
                }
            }

            //Aid object movement
            var plane = new THREE.Mesh(
                new THREE.PlaneBufferGeometry(500, 500, 8, 8),
                new THREE.MeshBasicMaterial({
                    //wireframe: true,
                    //color: 0xffffff,
                    visible: false
                })
            );
            scene.add(plane);

            //Lighting
            var light = new THREE.PointLight();
            light.position.set(5, 5, 5);
            light.intensity = 0.6;
            scene.add(light);

            var lighting = new THREEx.ThreePointsLighting();
            scene.add(lighting);

            document.addEventListener("mousedown", mouseDown, false);
            document.addEventListener("mouseup", mouseUp, false);
            document.addEventListener("mousemove", onMouseMove, false);
            window.addEventListener("resize", handleResize, false);

            function mouseDown(event) {
                event.preventDefault();

                mouse.set((event.clientX/WIDTH)*2 - 1, -(event.clientY/HEIGHT)*2 + 1);
                ray.setFromCamera(mouse, camera);
                var hits = ray.intersectObjects(sceneObjects);

                for(let i=0; i<hits.length; i++) {
                    let cplanes = hits[i].object.material.clippingPlanes;
                    if(cplanes.length > 0) {
                        if(cplanes.some(function(elem) { return elem.distanceToPoint(hits[i].point) < 0; })) {
                            continue; //Ignore hit outside clipping planes
                        }
                    }

                    selected = hits[i].object;
                    selected.material.transparent = true;
                    selected.material.opacity = 0.6;
                    controls.enabled = false;

                    //A new raycast is needed for the correct offset
                    mouse.set(0, -(event.clientY/HEIGHT)*2 + 1);
                    ray.setFromCamera(mouse, camera);
                    var hits = ray.intersectObject(plane);
                    offset.copy(hits[0].point).sub(selected.parent.position);
                }
            }

            function mouseUp(event) {
                if(selected != null) {
                    updateOrder(selected);
                    selected.material.transparent = false;
                    selected = null;
                    controls.enabled = true;
                }
            }

            function onMouseMove(event) { 
                event.preventDefault();

                mouse.set(0, -(event.clientY/HEIGHT)*2 + 1);
                ray.setFromCamera(mouse, camera);
                var hits = ray.intersectObjects(sceneObjects);

                if(selected != null) {
                    var hits = ray.intersectObject(plane);
                    if(hits.length > 0) {
                        //selected.parent.position.copy(hits[0].point);
                        var planeOffset = selected.parent.position.y;
                        selected.parent.position.copy(hits[0].point.sub(offset));
                        var planeIndex = objOrder.indexOf(selected.parent);
                        clipPlanes[planeIndex].forEach(function(plane) {
                            plane.translate(new THREE.Vector3(0, selected.parent.position.y - planeOffset, 0));
                        })
                    }

                    //Lock to y-axis
                    selected.position.x = 0;
                    selected.position.z = 0;

                    updateOrder(selected);
                }
            }

            function updateOrder(obj) {
                //Update position
                var pos = Math.min(Math.max(0, Math.round(obj.parent.position.y)), 3);
                console.log("updateOrder() position: " + pos);
                console.log("group position y read as : " + obj.parent.position.y);

                //Swap recorded order
                var cur = objOrder.indexOf(obj.parent);
                var temp = objOrder[pos];
                objOrder[cur] = temp;
                objOrder[pos] = obj.parent;

                //Swap clipping planes?
                var temp = clipPlanes[pos];
                clipPlanes[pos] = clipPlanes[cur];
                clipPlanes[cur] = temp;
                /*
                clipPlanes[cur].forEach(function(plane) {
                    plane.translate(new THREE.Vector3(0, cur - pos, 0));
                });
                clipPlanes[pos].forEach(function(plane) {
                    plane.translate(new THREE.Vector3(0, pos - cur, 0));
                });
                */
            }

            function handleResize() {
                WIDTH = window.innerWidth;
                HEIGHT = window.innerHeight;
                
                aspect = WIDTH / HEIGHT;
                camera.left = viewSize * aspect / - 2;
                camera.right = viewSize * aspect / 2;
                camera.top = viewSize / 2;
                camera.bottom = - viewSize / 2;

                camera.updateProjectionMatrix();
                renderer.setSize(WIDTH, HEIGHT);
                renderer.render(scene, camera);
            }

            function animate() {
                /* TODO
                Change the animation to move groups of objects with their clipping planes.
                */
                requestAnimationFrame(animate);

                controls.update();

                var done = true;
                //Interpolate each object to its placing
                objOrder.forEach(function(obj, i) {
                    if(obj.children.some(function(child){ return child == selected })) {
                        done = false;
                    } else if(obj.position.y == i) {
                        done = done && true;
                    } else {
                        done = false;
                        obj.position.lerp(new THREE.Vector3(0, i, 0), 0.1536);
                        //obj.position.copy(new THREE.Vector3(0, i, 0));
                        var planeLo = clipPlanes[i][0];
                        var planeHi = clipPlanes[i][1];
                        planeLo.set(planeLo.normal, THREE.Math.lerp(planeLo.constant, -i + 1, 0.1536));
                        planeHi.set(planeHi.normal, THREE.Math.lerp(planeHi.constant, i, 0.1536));
                    }
                });
                animFinished = done;

                renderer.render(scene, camera);
            }

            //shuffle();
            animate();

        </script>
    </body>
</html>