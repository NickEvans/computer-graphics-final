<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <title>three.js practice</title>
        <style>
            body { margin: 0; }
            canvas { width: 100%; height: 100%; }
        </style>
    </head>
    <body>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.min.js"></script>
        <script src='js/threex.basiclighting.js'></script>

        <script>
            var WIDTH = window.innerWidth;
            var HEIGHT = window.innerHeight;

            var aspect = WIDTH / HEIGHT;
            var viewSize = 10;

            var move = 0.01;

            var scene = new THREE.Scene();
            scene.background = new THREE.Color(0x949998);

            //var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            //var camera = new THREE.OrthographicCamera( WIDTH/-150, WIDTH/150, HEIGHT/150, HEIGHT/-150, 0, 5);
            var camera = new THREE.OrthographicCamera( viewSize * aspect / - 2, viewSize * aspect / 2, viewSize / 2, viewSize / - 2, 1, 1000 );


            camera.position.set(2,2,2);
            camera.lookAt(scene.position);

            camera.updateMatrixWorld(); //Needed?

            //camera.updateProjectionMatrix;
            //camera.updateMatrixWorld();

            var renderer = new THREE.WebGLRenderer({ antialias: true });

            //WIDTH /= 150;
            //HEIGHT /= 150;
            
            renderer.setSize(WIDTH, HEIGHT);
            document.body.appendChild(renderer.domElement);

            var geometry = new THREE.BoxGeometry(1, 1, 1);
            var material = new THREE.MeshPhongMaterial( );
            var cube1 = new THREE.Mesh(geometry, material);
            var cube2 = new THREE.Mesh(geometry, material);
            cube2.position.set(0, 1, 0);
            scene.add(cube1);
            scene.add(cube2);

            var sceneObjects = [];
            sceneObjects.push(cube1);
            sceneObjects.push(cube2);

            //Plane to aid object positioning
            var plane = new THREE.Mesh(
                new THREE.PlaneBufferGeometry(500, 500, 8, 8),
                new THREE.MeshBasicMaterial({
                    wireframe: true,
                    color: 0xffffff
                })
            );
            //plane.visible = false;
            //plane.lookAt(camera.position);
            scene.add(plane);

            var light = new THREE.PointLight();
            light.position.set(5, 5, 5);
            scene.add(light);
            var lighting = new THREEx.ThreePointsLighting()
            scene.add(lighting)


            var mouse = new THREE.Vector2();
            var pos = new THREE.Vector3();
            var ray = new THREE.Raycaster();
            var offset = new THREE.Vector3();
            var lockedpos;
            var selected = null;

            document.addEventListener('mousedown', function(){ 
                mouse.set((event.clientX/WIDTH)*2 - 1, -(event.clientY/HEIGHT)*2 + 1);

                ray.setFromCamera(mouse, camera);

                var hits = ray.intersectObjects(sceneObjects);

                if(hits.length > 0) {
                    selected = hits[0].object;
                    var hits = ray.intersectObject(plane);
                    offset.copy(hits[0].point).sub(plane.position);

                    //For debugging:
                    selected.material.color = new THREE.Color ('red');
                }
            });

            document.addEventListener('mouseup', function() {
                selected.material.color = new THREE.Color('white');
                console.log("finalpos: " + selected.position.x);
                selected = null;
            });

            document.addEventListener('mousemove', onMouseMove, false);

            function onMouseMove(event) { 
                event.preventDefault();

                mouse.set((event.clientX/WIDTH)*2 - 1, -(event.clientY/HEIGHT)*2 + 1);
                ray.setFromCamera(mouse, camera);
                var hits = ray.intersectObjects(sceneObjects);

                if(selected != null) {
                    var hits = ray.intersectObject(plane);
                    //var temp = selected.position.x;
                    //selected.position.copy(hits[0].point.sub(offset));
                    selected.position.copy(hits[0].point);
                    selected.position.x = 0;
                    selected.position.z = 0;
                    //selected.position.x = temp;
                } else {
                    var hits = ray.intersectObjects(sceneObjects);
                    if(hits.length > 0) {
                        //plane.position.copy(hits[0].object.position);
                        //plane.lookAt(camera.position);
                    }
                }
                /*
                vec.set((event.clientX/window.innerWidth)*2-1, - (event.clientY/window.innerHeight)*2+1, 0.5);
                vec.unproject(camera);
                vec.sub(camera.position).normalize();

                var distance = ( 2 - camera.position.z) / vec.z;

                pos.copy(camera.position).add(vec.multiplyScalar(distance));

                light.position.copy(pos); */
            }

            function animate() {
                requestAnimationFrame(animate);

                //cube1.rotation.x += move;
                //cube1.rotation.y += move;

                renderer.render(scene, camera);
            }

            animate();
        </script>
    </body>
</html>