<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <title>CAP 4720 Final Project</title>
        <style>
            body { margin: 0; }
            canvas { width: 100%; height: 100%; }
        </style>
    </head>
    <body>
        <script src="js/three.min.js"></script>
        <script src="https://threejs.org/examples/js/loaders/OBJLoader.js"></script>
        <script src='js/threex.basiclighting.js'></script>
        <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
        <script src='js/threex.basiclighting.js'></script>
        <script>
            //Global declarations
            var WIDTH, HEIGHT, viewSize, mouse, ray, offset, selected;
            var scene, camera, renderer, controls, loader, light, lighting;
            var clipPlanes, sceneObjects, objOrder, model, objColor, colors, plane;

            init();
            animate();

            function init() {
                //View settings
                WIDTH = window.innerWidth;
                HEIGHT = window.innerHeight;
                var aspect = WIDTH / HEIGHT;
                viewSize = 6;

                //Model
                clipPlanes = new Array(4);
                model = new THREE.Mesh();
                objColor = new THREE.Color(0xB6CEC7);
                objColorSelect = new THREE.Color(0xC5DED7);

                //Colors
                colors = [];
                colors.push(new THREE.Color(0xA8E6CF));
                colors.push(new THREE.Color(0xDCEDC1));
                colors.push(new THREE.Color(0xFFD3B6));
                colors.push(new THREE.Color(0xFFAAA5));

                //Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x86A3C3);

                //Interactivity
                mouse = new THREE.Vector2();
                ray = new THREE.Raycaster();
                offset = new THREE.Vector3();
                selected = null;
                //Aid object movement
                plane = new THREE.Mesh(
                    new THREE.PlaneBufferGeometry(500, 500, 8, 8),
                    new THREE.MeshBasicMaterial({
                        //wireframe: true,
                        //color: 0xffffff,
                        visible: false
                    })
                );
                scene.add(plane);

                //Camera
                camera = new THREE.OrthographicCamera( viewSize * aspect / - 2, viewSize * aspect / 2, viewSize / 2, viewSize / - 2, 1, 1000 );
                camera.position.set(100,100,100);
                camera.lookAt(scene.position);
                camera.updateProjectionMatrix();
                camera.updateMatrixWorld();

                //Lighting
                var light = new THREE.PointLight(0xffffff, 0.5);
                light.position.set(5, 5, 5);
                light.intensity = 0.5;
                scene.add(light);
                var lighting = new THREEx.ThreePointsLighting();
                scene.add(lighting);

                //Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(WIDTH, HEIGHT);
                renderer.localClippingEnabled = true;
                document.body.appendChild(renderer.domElement);

                //Controls
                controls = new THREE.OrbitControls (camera, renderer.domElement);
                controls.addEventListener("change",
                function(){
                    camera.updateProjectionMatrix();
                    camera.updateMatrixWorld();
                });
                controls.maxPolarAngle = Math.PI/3;
                controls.minPolarAngle = Math.PI/3;
                controls.minAzimuthAngle = -Math.PI/8;
                controls.maxAzimuthAngle = Math.PI/2.2;

                //Load models and initialize effects
                sceneObjects = []; //Interactables
                objOrder = []; //Record of stacked order
                var loader = new THREE.OBJLoader();
                loader.load(
                    "models/knight.obj", //"Knight Chess Piece" from Poly by Google is licensed under CC BY 2.0 - https://poly.google.com/view/aW5HcCo0KZa

                    function(obj) {
                        obj.traverse(function(child) {
                            if(child instanceof THREE.Mesh) {
                                var mod = child.clone();

                                //Create slices!
                                addMeshes(mod);
                            }
                        });
                    },

                    //Display load progress
                    function(xhr) {
                        if(xhr.lengthComputable) {
                            var percentComplete = xhr.loaded / xhr.total * 100;
                            console.log("Model " + Math.round(percentComplete, 2) + "% loaded");
                        }
                    });

                //Listeners
                document.addEventListener("mousedown", mouseDown, false);
                document.addEventListener("mouseup", mouseUp, false);
                document.addEventListener("mousemove", onMouseMove, false);
                window.addEventListener("resize", handleResize, false);
            }

            //Create a mesh copy for each object that writes to stencil buffer
            function createStencilGroup(object, planes, rendOrder) {
                var stenGroup = new THREE.Group();

                //Basic stencil parameters for both sides
                var material = new THREE.MeshBasicMaterial({
                    depthWrite: false,
                    depthTest: true,
                    colorWrite: true,
                    stencilWrite: true,
                    stencilFunc: THREE.AlwaysStencilFunc,
                });

                //Backsides 
                var materialBack = material.clone();
                materialBack.side = THREE.BackSide;
                materialBack.clippingPlanes = planes;
                materialBack.stencilFail = THREE.IncrementWrapStencilOp;
                materialBack.stencilZFail = THREE.IncrementWrapStencilOp;
                materialBack.stencilZPass = THREE.IncrementWrapStencilOp;

                //Frontside 
                var materialFront = material.clone();
                materialFront.side = THREE.FrontSide;
                materialFront.clippingPlanes = planes;
                materialFront.stencilFail = THREE.DecrementWrapStencilOp;
                materialFront.stencilZFail = THREE.DecrementWrapStencilOp;
                materialFront.stencilZPass = THREE.DecrementWrapStencilOp;

                //Create front + back mesh group
                //Where there is a front or back mesh, stencil is written
                var meshBack = new THREE.Mesh(object, materialBack);
                var meshFront = new THREE.Mesh(object, materialFront);
                meshBack.renderOrder = rendOrder;
                meshFront.renderOrder = rendOrder;
                stenGroup.add(meshBack);
                stenGroup.add(meshFront);

                return stenGroup;
            }

            //Create slices for the loaded model
            //Each slice is a full copy clipped by two planes
            var meshPlanes = [];
            function addMeshes(mod) {
                for(let i=0; i<4; i++) {
                    //Group contains visible slice mesh along with stencil mesh and plane
                    var group = new THREE.Group(); 
                    
                    scene.add(group);
                    
                    //A set of clipping planes creates a slice of an object
                    clipPlanes[i] = new Array(2);
                    clipPlanes[i][0] = new THREE.Plane(
                        //Lower plane
                        new THREE.Vector3(0, 1, 0),
                        -i + 1
                    );
                    clipPlanes[i][1] = new THREE.Plane(
                        //Upper plane
                        new THREE.Vector3(0, -1, 0),
                        i + 0
                    );

                    /// STENCIL PLANE RENDERING
                    var meshPlaneGroup = new THREE.Group;
                    //var meshPlanes = [];
                    var meshPlaneGeometry = new THREE.PlaneBufferGeometry(2, 2);

                    ///////for(var j=0; j<2; j++) {
                        //var planeMeshGroup = new THREE.Group();
                        var plane = clipPlanes[i];
                        var meshStencilGroup = createStencilGroup(mod.geometry, plane, i);
                        meshStencilGroup.position.set(0,-i,0); //Same offset as visible geometry

                        //Plane fills in hollow section of clipped geometry
                        var meshPlaneMaterial = new THREE.MeshStandardMaterial({
                            color: colors[i],
                            metalness: 0.1,
					        roughness: 0.75,
                            stencilWrite: true,
                            //colorWrite: true,
                            //depthWrite: true,
							stencilRef: 0,
							stencilFunc: THREE.NotEqualStencilFunc,
							stencilFail: THREE.ReplaceStencilOp,
							stencilZFail: THREE.ReplaceStencilOp,
							stencilZPass: THREE.ReplaceStencilOp,
                        });

                        var meshPlane = new THREE.Mesh(meshPlaneGeometry, meshPlaneMaterial);
                        
                        //planeRenderCounter++;
                        meshPlane.name = "Plane";
                        
                        meshPlane.onAfterRender = function(renderer, scene, camera, geometry, material, group) {
                            renderer.clearStencil();
                            //console.log("Stencil cleared after rendering mesh on order " + material.renderOrder);
                        };
                        
                        
                        meshPlaneMaterial.renderOrder =  i+1;
                        
                        
                        group.add(meshStencilGroup);
                        group.add(meshPlane);
                        meshPlaneGroup.add(meshPlane);
                        meshPlanes.push(meshPlane);
                        //console.log("A thing was pushed... " + meshPlanes.length);
                        scene.add(meshPlaneGroup);
                        
                    /////////}

                    //Visible clipped geometry
                    var c = new THREE.Mesh(
                        mod.geometry,
                        new THREE.MeshStandardMaterial ({
                            color: objColor,
                            metalness: 0.1,
                            roughness: 0.75,
                            clippingPlanes: clipPlanes[i],
                            //side: THREE.DoubleSide,
                            //depthWrite: true,
                            //clipShadows: true,
                            //shadowSide: THREE.DoubleSide,
                            //visible: false
                        })
                    );
                    
                    c.position.set(0,-i,0); //An offset so each slice is different
                    group.add(c);

                    //Prevents banding where meshes overlap
                    //c.material.polygonOffset = true;
                    //c.material.polygonOffsetFactor = -0.1*i;

                    c.material.renderOrder = 0;
                    
                    //Scale the slice to size

                    /*
                    let bbox = new THREE.Box3().setFromObject(c);
                    let size = bbox.getSize();
                    c.scale.set(4 / size.y, 4 / size.y, 4 / size.y);
                    */

                    sceneObjects.push(c);
                    objOrder.push(group);
                    
                    //Move the slice into place (not required)
                    group.position.y = i;
                }
            }


            //Handle events
            function mouseDown(event) {
                event.preventDefault();

                mouse.set((event.clientX/WIDTH)*2 - 1, -(event.clientY/HEIGHT)*2 + 1);
                ray.setFromCamera(mouse, camera);
                var hits = ray.intersectObjects(sceneObjects);

                for(let i=0; i<hits.length; i++) {
                    let cplanes = hits[i].object.material.clippingPlanes;
                    if(cplanes.length > 0) {
                        if(cplanes.some(function(elem) { return elem.distanceToPoint(hits[i].point) < 0; })) {
                            continue; //Ignore hit outside clipping planes
                        }
                    }

                    selected = hits[i].object;
                    //selected.material.transparent = true;
                    //selected.material.opacity = 0.6;
                    selected.material.color = objColorSelect;
                    
                    //This isn't working:
                    selected.parent.children.forEach(function(child) {
                        if(child.material) {
                            if(child.material.color == objColor) {
                                child.material.color = objColorSelect;
                            }
                        }
                    })
                    //


                    controls.enabled = false;

                    //A new raycast is needed for the correct offset
                    mouse.set(0, -(event.clientY/HEIGHT)*2 + 1);
                    ray.setFromCamera(mouse, camera);
                    var hits = ray.intersectObject(plane);
                    offset.copy(hits[0].point).sub(selected.parent.position);
                }
            }

            function mouseUp(event) {
                if(selected != null) {
                    //updateOrder(selected);
                    //selected.material.transparent = false;
                    selected.material.color = objColor;
                    selected = null;
                    controls.enabled = true;
                }
            }

            function onMouseMove(event) { 
                event.preventDefault();

                mouse.set(0, -(event.clientY/HEIGHT)*2 + 1);
                ray.setFromCamera(mouse, camera);
                var hits = ray.intersectObjects(sceneObjects);

                if(selected != null) {
                    var hits = ray.intersectObject(plane);
                    if(hits.length > 0) {
                        //selected.parent.position.copy(hits[0].point);
                        var planeOffset = selected.parent.position.y;
                        selected.parent.position.copy(hits[0].point.sub(offset));
                        var planeIndex = objOrder.indexOf(selected.parent);
                        clipPlanes[planeIndex].forEach(function(plane) {
                            plane.translate(new THREE.Vector3(0, selected.parent.position.y - planeOffset, 0));
                        })
                    }

                    //Lock to y-axis
                    selected.position.x = 0;
                    selected.position.z = 0;

                    //updateOrder(selected);
                }
            }

            function updateOrder(obj) {
                //Update position
                var pos = Math.min(Math.max(0, Math.round(obj.parent.position.y)), 3);

                //Swap recorded order
                var cur = objOrder.indexOf(obj.parent);
                var temp = objOrder[pos];
                objOrder[cur] = temp;
                objOrder[pos] = obj.parent;

                //Swap clipping planes?
                
                var temp = clipPlanes[pos];
                clipPlanes[pos] = clipPlanes[cur];
                clipPlanes[cur] = temp;
                

                /*
                clipPlanes[cur].forEach(function(plane) {
                    plane.translate(new THREE.Vector3(0, cur - pos, 0));
                });
                clipPlanes[pos].forEach(function(plane) {
                    plane.translate(new THREE.Vector3(0, pos - cur, 0));
                });
                */
            }

            function handleResize() {
                WIDTH = window.innerWidth;
                HEIGHT = window.innerHeight;
                
                aspect = WIDTH / HEIGHT;
                camera.left = viewSize * aspect / - 2;
                camera.right = viewSize * aspect / 2;
                camera.top = viewSize / 2;
                camera.bottom = - viewSize / 2;

                camera.updateProjectionMatrix();
                renderer.setSize(WIDTH, HEIGHT);
                renderer.render(scene, camera);
            }

            //Animation loop
            var t = 0.0;
            function animate() {
                requestAnimationFrame(animate);

                controls.update();

                var done = true;
                //Interpolate each object to its placing
                
                objOrder.forEach(function(obj, i) {
                    var planeLo = clipPlanes[i][0];
                    var planeHi = clipPlanes[i][1];

                    /*
                    if(obj.children.some(function(child){ return child == selected })) {
                        done = false;
                    } else if(Math.abs(Number.parseFloat(obj.position.y).toFixed(2)) == Number.parseFloat(i).toFixed(2)) {
                        done = done && true;
                        //Snap to prevent gaps, or a lengthy animation
                        obj.position.copy(new THREE.Vector3(0, i, 0));
                        planeLo.set(planeLo.normal, -i + 1);
                        planeHi.set(planeHi.normal, i);
                    } else {
                        done = false;
                        obj.position.lerp(new THREE.Vector3(0, i, 0), 0.1536);
                        planeLo.set(planeLo.normal, THREE.Math.lerp(planeLo.constant, -i + 1, 0.1536));
                        planeHi.set(planeHi.normal, THREE.Math.lerp(planeHi.constant, i, 0.1536));
                    }
                    */

                    //Adjust plane objects to clipping planes
                    //var meshLo = meshPlanes[i*2];
                    var meshHi = meshPlanes[i];
                    //console.log(planeLo.normal.y);
                    //console.log(meshLo.position.y);

                    /*
                    planeLo.coplanarPoint(meshLo.position);
                    
                    meshLo.lookAt(
						meshLo.position.x - planeLo.normal.x,
						meshLo.position.y - planeLo.normal.y,
						meshLo.position.z - planeLo.normal.z,
                    );
                    */
                    
                    planeHi.coplanarPoint(meshHi.position);
                    meshHi.lookAt(
						meshHi.position.x - planeHi.normal.x,
						meshHi.position.y - planeHi.normal.y,
						meshHi.position.z - planeHi.normal.z,
                    );
                    //meshHi.position.x -= 0.01;
                    


                });
                
                animFinished = done;

                if(animFinished) {
                    if(objOrder.every(function(group) {
                        group.updateMatrixWorld();
                        var vector = new THREE.Vector3();
                        vector.setFromMatrixPosition(group.children[0].matrixWorld);
                        return (vector.equals(new THREE.Vector3(0, 0, 0)));
                    })) {
                        solved = true;
                    } else {
                        solved = false;
                        t = 0.0;
                        objOrder.forEach(function(group) {
                            group.rotation.y = 0;
                        })
                    }
                }

                if(solved) {
                        objOrder.forEach(function(group) {
                            group.rotation.y = smoothLerp(0, 80, t) * 2 * Math.PI;
                        })
                        t += 1;
                }

                renderer.render(scene, camera);
            }

            function smoothLerp(min, max, x) {
                var p = Math.max(0.0, Math.min(1.0, (x - min) / (max - min)));
                if(p == 1) {
                    spinning = false;
                }
                return p * p * (3.0 - 2.0 * p);
            }

            animate();

        </script>
    </body>
</html>